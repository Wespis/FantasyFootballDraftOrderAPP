<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Draft Night Show — Briefcase Punishment + Combine + Draft (v6)</title>
<style>
:root{
  --bg1:#02030a; --bg2:#070b1a; --bg3:#050814;
  --text:#f4f7ff; --muted:rgba(244,247,255,.72);
  --line:rgba(255,255,255,.14);
  --accent:#3aa7ff; --gold:#ffbf2a; --danger:#ff3b4d; --good:#36e57a;
  --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
  --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
}
*{box-sizing:border-box}
html,body{height:100%}
body{
  margin:0; color:var(--text); font-family:var(--sans);
  background:
    radial-gradient(1100px 700px at 18% -10%, rgba(58,167,255,.18), transparent 60%),
    radial-gradient(900px 600px at 110% 20%, rgba(255,191,42,.10), transparent 55%),
    linear-gradient(180deg, var(--bg1), var(--bg2) 70%, var(--bg3));
  overflow:hidden;
}
#wrap{position:fixed; inset:0}
canvas{position:absolute; inset:0; width:100%; height:100%; display:block;}
/* HUD */
.hud{position:absolute; inset:0; pointer-events:none; padding:14px; display:flex; flex-direction:column; gap:12px;}
.topbar{
  pointer-events:auto;
  display:flex; align-items:center; justify-content:space-between; gap:12px;
  padding:10px 12px; border-radius:18px;
  background: rgba(0,0,0,.35); border:1px solid var(--line);
  backdrop-filter: blur(10px);
}
.brand{display:flex; align-items:center; gap:10px; min-width:0}
.badge{
  font-family:var(--mono);
  font-weight:900; letter-spacing:.6px;
  padding:4px 10px; border-radius:999px;
  border:1px solid rgba(255,255,255,.16);
  background: rgba(255,255,255,.06);
  white-space:nowrap;
}
.title{font-weight:950; letter-spacing:1px; text-transform:uppercase; font-size:13px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width:44vw}
.sub{font-size:12px; color:var(--muted)}
.right{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
.btn{
  pointer-events:auto;
  cursor:pointer;
  border:1px solid rgba(255,255,255,.18);
  background: rgba(255,255,255,.06);
  color:var(--text);
  border-radius:12px; padding:9px 11px;
  font-weight:850;
  transition: transform .06s ease, background .12s ease;
  user-select:none;
}
.btn:hover{background: rgba(255,255,255,.09)}
.btn:active{transform: translateY(1px)}
.btn.primary{border-color: rgba(58,167,255,.35); background: rgba(58,167,255,.16)}
.btn.gold{border-color: rgba(255,191,42,.35); background: rgba(255,191,42,.14)}
.btn.danger{border-color: rgba(255,59,77,.35); background: rgba(255,59,77,.14)}
.btn.good{border-color: rgba(54,229,122,.35); background: rgba(54,229,122,.14)}
.btn:disabled{opacity:.45; cursor:not-allowed}
.kbd{
  font-family:var(--mono); font-weight:900; font-size:11px;
  padding:3px 7px; border-radius:9px;
  border:1px solid rgba(255,255,255,.16);
  background: rgba(0,0,0,.30);
}
.panel{
  pointer-events:auto;
  position:absolute; right:14px; top:74px;
  width:min(520px, calc(100% - 28px));
  max-height: calc(100% - 160px);
  overflow:auto;
  background: rgba(0,0,0,.42);
  border:1px solid rgba(255,255,255,.14);
  border-radius:18px;
  backdrop-filter: blur(10px);
  box-shadow: 0 18px 55px rgba(0,0,0,.45);
}
.panel::-webkit-scrollbar{width:10px}
.panel::-webkit-scrollbar-thumb{background:rgba(255,255,255,.18); border-radius:999px}
.panel::-webkit-scrollbar-track{background:rgba(255,255,255,.06)}
.panel .head{padding:12px; border-bottom:1px solid rgba(255,255,255,.10)}
.panel .head .h{font-weight:950; letter-spacing:1px; text-transform:uppercase; font-size:12px}
.panel .body{padding:12px}
.field{display:flex; flex-direction:column; gap:6px; margin-bottom:10px}
label{font-size:12px; color:var(--muted)}
input, select{
  width:100%;
  padding:10px 10px;
  border-radius:12px;
  border:1px solid rgba(255,255,255,.16);
  background: rgba(0,0,0,.35);
  color:var(--text);
  outline:none;
}
.row{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
.mini{font-size:11px; color:rgba(244,247,255,.62); line-height:1.35}
.teamList{display:flex; flex-direction:column; gap:8px}
.teamItem{
  display:flex; gap:8px; align-items:center;
  padding:10px;
  border-radius:16px;
  border:1px solid rgba(255,255,255,.12);
  background: rgba(255,255,255,.04);
}
.swatch{width:18px; height:18px; border-radius:6px; border:1px solid rgba(255,255,255,.18)}
.teamItem input[type="text"]{flex:1}
.teamItem input[type="color"]{width:58px; height:42px; padding:6px}


.smallbtn{padding:8px 10px; border-radius:12px}

.toast{
  pointer-events:none;
  position:absolute; left:14px; right:14px; bottom:14px;
  display:flex; justify-content:center;
}
.toast .box{
  width:min(1100px, 100%);
  border-radius:18px;
  border:1px solid rgba(255,255,255,.18);
  background: rgba(0,0,0,.70);
  backdrop-filter: blur(12px);
  overflow:hidden;
  box-shadow: 0 22px 70px rgba(0,0,0,.55);
  transform: translateY(12px); opacity:0;
  transition: opacity .22s ease, transform .22s ease;
}
.toast.on .box{opacity:1; transform: translateY(0)}
.toast .top{
  display:flex; gap:10px; align-items:center;
  padding:10px 12px;
  background: linear-gradient(90deg, rgba(58,167,255,.30), rgba(255,191,42,.18));
  border-bottom:1px solid rgba(255,255,255,.12);
}
.toast .main{
  padding:12px;
  display:flex; align-items:flex-end; justify-content:space-between; gap:12px;
}
.toast .big{font-size:28px; font-weight:1000; letter-spacing:.8px; text-transform:uppercase}
.toast .small{font-family:var(--mono); font-size:12px; color:rgba(244,247,255,.76)}
</style>
</head>
<body>
<div id="wrap">
  <canvas id="c"></canvas>

  <div class="hud" id="hud"></div>

  <div class="toast" id="toast"><div class="box">
    <div class="top">
      <span class="badge" id="toastTag">LIVE</span>
      <div class="title" id="toastTitle">DRAFT NIGHT SHOW</div>
      <div style="flex:1"></div>
      <div class="small" id="toastRight"></div>
    </div>
    <div class="main">
      <div>
        <div class="big" id="toastBig">—</div>
        <div class="small" id="toastSmall">—</div>
      </div>
      <div class="small" id="toastHint">—</div>
    </div>
  </div></div>
</div>

<script>
/* ==========================================================
   Draft Night Show — v6
   Flow:
     SETUP → BRIEFCASE PUNISHMENT → COMBINE (round-based) → DRAFT STAGE → RESULTS/PROOF
   Punishment:
     - 5 briefcases with hidden numbers 1–50
     - Last place clicks one
     - Chosen reveals immediately
     - Remaining cases then open one-by-one slowly, dramatically
========================================================== */

/* ---------- Utilities ---------- */
const $ = (q)=>document.querySelector(q);
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const lerp=(a,b,t)=>a+(b-a)*t;
const easeInOut=(t)=> t<.5 ? 2*t*t : 1- Math.pow(-2*t+2,2)/2;
const hexToRgb=(hex)=>{
  const m=String(hex||"#3aa7ff").replace("#","");
  const n=parseInt(m.length===3 ? m.split("").map(x=>x+x).join("") : m,16);
  return {r:(n>>16)&255, g:(n>>8)&255, b:n&255};
};
function escapeHtml(s){return String(s??"").replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;").replaceAll('"',"&quot;");}

/* ---------- Provable RNG (commit + seed) ---------- */
async function sha256Hex(str){
  const enc=new TextEncoder().encode(str);
  const buf=await crypto.subtle.digest("SHA-256", enc);
  return [...new Uint8Array(buf)].map(b=>b.toString(16).padStart(2,"0")).join("");
}
function randBytes(n){ const a=new Uint8Array(n); crypto.getRandomValues(a); return a; }
function bytesToHex(bytes){ return [...bytes].map(b=>b.toString(16).padStart(2,"0")).join(""); }
async function newProof(){
  const seed=bytesToHex(randBytes(32));
  const commit=await sha256Hex(seed);
  return {seed, commit};
}
async function detFloat(seed, label, i, min, max, decimals=2){
  const s = `${seed}|${label}|${i}`;
  const h = await sha256Hex(s);
  const n = parseInt(h.slice(0,12),16);
  const t = n / 0xFFFFFFFFFFFF;
  const v = min + (max-min)*t;
  const p = 10**decimals;
  return Math.round(v*p)/p;
}
async function detInt(seed,label,i,min,max){
  const h = await sha256Hex(`${seed}|${label}|${i}`);
  const n = parseInt(h.slice(0,8), 16);
  const span = max-min+1;
  return min + (n % span);
}

/* ---------- Defaults + storage ---------- */
const STORAGE_KEY="draftnight_singlefile_v6";
const DEFAULT_TEAMS = [
  { name:"Team A", color:"#3aa7ff" }, { name:"Team B", color:"#ffbf2a" },
  { name:"Team C", color:"#35d0ff" }, { name:"Team D", color:"#ff3b4d" },
  { name:"Team E", color:"#36e57a" }, { name:"Team F", color:"#b070ff" },
  { name:"Team G", color:"#ff7a3a" }, { name:"Team H", color:"#56ffd3" },
  { name:"Team I", color:"#ffd356" }, { name:"Team J", color:"#7aa8ff" },
  { name:"Team K", color:"#ff56b6" }, { name:"Team L", color:"#a6ff56" }
];
const state = {
  leagueName:"Draft Night Show",
  teams: DEFAULT_TEAMS.map(t=>({...t})),

  lastPlaceName: "Last Place",
  champName: "Last Year Champ",
  buyIn: 37,
  penaltyMode: "dollars", // dollars | percent_of_buyin

  mode:"setup", // setup | punishment | combine | stage | results
  proof:null,
  sfxOn:false
  ,musicOn:false,
  uiOpen:true,

  punishment: {
    cases:[],           // [{slot, value, opened, isChosen, openT}]
    chosenSlot:null,
    revealQueue:[],
    revealTimer:0,
    phase:"intro",      // intro | choose | revealOthers | revealChosenOpen | revealChosenToast | done
    finalNumber:null,
    chosenToastPending:false,
    chosenToastTimer:0,
    showFinal:false
  },

  combine: { metrics:[], revealed:{forty:{}, bench:{}, shuttle:{}}, totals:[] },
  order:[],
  orderStats:[],
  appearance: {} // teamName -> sprite parts
};
function saveCfg(){
  localStorage.setItem(STORAGE_KEY, JSON.stringify({
    leagueName: state.leagueName,
    teams: state.teams,
    sfxOn: state.sfxOn,
      musicOn: state.musicOn,
    lastPlaceName: state.lastPlaceName,
    champName: state.champName,
    buyIn: state.buyIn,
    penaltyMode: state.penaltyMode
  }));
}
function loadCfg(){
  const raw = localStorage.getItem(STORAGE_KEY);
  if(!raw) return;
  try{
    const cfg = JSON.parse(raw);
    if(cfg.leagueName) state.leagueName = cfg.leagueName;
    if(Array.isArray(cfg.teams) && cfg.teams.length) state.teams = cfg.teams;
    state.sfxOn = !!cfg.sfxOn; state.musicOn = !!cfg.musicOn;
    if(cfg.lastPlaceName) state.lastPlaceName = cfg.lastPlaceName;
    if(cfg.champName) state.champName = cfg.champName;
    if(Number.isFinite(+cfg.buyIn)) state.buyIn = +cfg.buyIn;
    if(cfg.penaltyMode) state.penaltyMode = cfg.penaltyMode;
  }catch{}
}
function clearCfg(){
  localStorage.removeItem(STORAGE_KEY);
  state.leagueName="Draft Night Show";
  state.teams = DEFAULT_TEAMS.map(t=>({...t}));
  state.sfxOn=false; state.musicOn=false;
  state.lastPlaceName="Last Place";
  state.champName="Last Year Champ";
  state.buyIn=37;
  state.penaltyMode="dollars";
}

/* ---------- Tiny audio (browser-friendly, click-to-enable) ---------- */
let audioCtx=null;
function ensureAudio(){
  if(audioCtx) return true;
  try{
    audioCtx = new (window.AudioContext||window.webkitAudioContext)();
    // iOS/Safari often starts suspended until a user gesture calls resume.
    if(audioCtx && audioCtx.state==="suspended" && audioCtx.resume) audioCtx.resume();
    return true;
  }catch(e){
    console.warn("Audio init failed:", e);
    // Fail gracefully: disable audio but keep the show running.
    state.sfxOn=false; state.musicOn=false;
    stopMusic?.();
    buildHUD?.();
    return false;
  }
}
function tone(f=440, d=0.12, type="sine", v=0.06){
  if(!state.sfxOn) return;
  if(!ensureAudio()) return;
  const t0=audioCtx.currentTime;
  const o=audioCtx.createOscillator();
  const g=audioCtx.createGain();
  o.type=type; o.frequency.setValueAtTime(f,t0);
  g.gain.setValueAtTime(v,t0);
  g.gain.exponentialRampToValueAtTime(0.0001, t0+d);
  o.connect(g).connect(audioCtx.destination);
  o.start(t0); o.stop(t0+d);
}

// --- richer SFX / music (all synthesized; no copyrighted samples) ---
let musicTimer=null;
let musicOn=false;
function stopMusic(){
  musicOn=false;
  if(musicTimer){ clearInterval(musicTimer); musicTimer=null; }
}
function startMusic(){
  if(!state.sfxOn) return;
  if(!ensureAudio()) return;
  if(audioCtx && audioCtx.state==="suspended" && audioCtx.resume) audioCtx.resume();
  if(musicOn) return;
  musicOn=true;

  // Simple stadium-electro loop (chords + kick), scheduled with setInterval.
  // This stays lightweight and works offline.
  const bpm = 108;
  const stepMs = (60/bpm)*1000/2; // eighth notes
  let step=0;

  const scale = [0,2,3,5,7,10]; // minor-ish
  const root = 110; // A2

  function kick(){
    // short thump with pitch drop
    const t0 = audioCtx.currentTime;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type="sine";
    o.frequency.setValueAtTime(90, t0);
    o.frequency.exponentialRampToValueAtTime(40, t0+0.10);
    g.gain.setValueAtTime(0.09, t0);
    g.gain.exponentialRampToValueAtTime(0.0001, t0+0.12);
    o.connect(g).connect(audioCtx.destination);
    o.start(t0); o.stop(t0+0.14);
  }
  function hat(){
    // noise hat (approx) using square at high freq
    const t0 = audioCtx.currentTime;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type="square";
    o.frequency.setValueAtTime(7600, t0);
    g.gain.setValueAtTime(0.015, t0);
    g.gain.exponentialRampToValueAtTime(0.0001, t0+0.04);
    o.connect(g).connect(audioCtx.destination);
    o.start(t0); o.stop(t0+0.05);
  }
  function chord(t0, f1, f2, f3, dur=0.30){
    const g = audioCtx.createGain();
    g.gain.setValueAtTime(0.0001, t0);
    g.gain.exponentialRampToValueAtTime(0.035, t0+0.02);
    g.gain.exponentialRampToValueAtTime(0.0001, t0+dur);
    g.connect(audioCtx.destination);
    for(const f of [f1,f2,f3]){
      const o = audioCtx.createOscillator();
      o.type="sawtooth";
      o.frequency.setValueAtTime(f, t0);
      o.connect(g);
      o.start(t0); o.stop(t0+dur+0.02);
    }
  }

  musicTimer = setInterval(()=>{
    try{
    if(!musicOn || !state.musicOn) return;

    // beat
    if(step%4===0) kick();
    if(step%2===1) hat();

    // chord every bar
    if(step%8===0){
      const deg = (Math.floor(step/8)) % 4;
      const note = scale[(deg*2)%scale.length];
      const f = root * Math.pow(2, note/12);
      chord(audioCtx.currentTime, f, f*Math.pow(2,7/12), f*2, 0.34);
    }

    step++;
    }catch(e){
      console.warn('Music loop error', e);
      stopMusic();
      state.sfxOn=false; state.musicOn=false;
      buildHUD();
    }
  }, stepMs);
}




function whistle(){
  if(!state.sfxOn) return;
  if(!ensureAudio()) return;

  // Quieter sports whistle (same timing as v18, just lower gain)
  const t0 = audioCtx.currentTime;

  const osc = audioCtx.createOscillator();
  const lfo = audioCtx.createOscillator();
  const lfoGain = audioCtx.createGain();
  const gain = audioCtx.createGain();

  osc.type = "triangle";
  osc.frequency.setValueAtTime(2150, t0);

  // Gentle vibrato
  lfo.type = "sine";
  lfo.frequency.setValueAtTime(6.5, t0);
  lfoGain.gain.setValueAtTime(22, t0);
  lfo.connect(lfoGain).connect(osc.frequency);

  // Envelope (lower peak)
  gain.gain.setValueAtTime(0.0001, t0);
  gain.gain.exponentialRampToValueAtTime(0.038, t0 + 0.05);
  gain.gain.setValueAtTime(0.038, t0 + 0.38);
  gain.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.52);

  osc.connect(gain).connect(audioCtx.destination);

  osc.start(t0);
  osc.stop(t0 + 0.55);
  lfo.start(t0);
  lfo.stop(t0 + 0.55);
}





function draftChime(){
  if(!state.sfxOn) return;
  if(!ensureAudio()) return;

  // Longer "broadcast pick" flourish (custom, not ESPN): rising arpeggio + resolve + sparkle.
  const now = audioCtx.currentTime;
  const seq = [
    {f:523.25, d:0.10, t:0.00}, // C5
    {f:659.25, d:0.10, t:0.10}, // E5
    {f:783.99, d:0.10, t:0.20}, // G5
    {f:1046.50,d:0.14, t:0.30}, // C6
    {f:1174.66,d:0.12, t:0.44}, // D6
    {f:1318.51,d:0.12, t:0.56}, // E6
    {f:1567.98,d:0.16, t:0.68}, // G6
    {f:1318.51,d:0.12, t:0.86}, // E6 (resolve-ish)
    {f:1046.50,d:0.20, t:0.98}, // C6 hold
  ];

  seq.forEach(n=>{
    setTimeout(()=>{
      // two-layer tone for sparkle
      tone(n.f, n.d, "triangle", 0.050);
      setTimeout(()=>tone(n.f*2.01, Math.max(0.06, n.d*0.6), "sine", 0.018), 8);
    }, Math.floor(n.t*1000));
  });

  // tiny shimmer tail
  setTimeout(()=>tone(2093.0, 0.08, "sine", 0.015), 1180);
  setTimeout(()=>tone(2637.0, 0.08, "sine", 0.012), 1260);
}


function stinger(){
  tone(196,.10,"triangle",.050);
  setTimeout(()=>tone(392,.12,"square",.045),90);
  setTimeout(()=>tone(523.25,.12,"square",.040),190);
  setTimeout(()=>tone(784.0,.18,"sawtooth",.034),320);
}
function blip(){ tone(880,.06,"square",.030); }
function thump(){ tone(110,.18,"sawtooth",.045); }
function crowd(){ tone(65,.22,"sawtooth",.020); setTimeout(()=>tone(98,.28,"triangle",.020),120); }

/* ---------- HUD / Setup Panel ---------- */
function toast(tag,big,small,hint=""){
  const t=$("#toast");
  $("#toastTag").textContent=tag;
  $("#toastBig").textContent=big;
  $("#toastSmall").textContent=small;
  $("#toastHint").textContent=hint;
  t.classList.add("on");
  clearTimeout(t._t);
  t._t=setTimeout(()=>t.classList.remove("on"),1800);
}
function modeSub(){
  if(state.mode==="setup") return "SETUP → BRIEFCASES → COMBINE → DRAFT";
  if(state.mode==="punishment") return "LAST PLACE BRIEFCASE REVEAL";
  if(state.mode==="combine") return "COMBINE (MANUAL) • ALL TEAMS PER EVENT";
  if(state.mode==="stage") return "DRAFT STAGE WALK-ONS";
  return "PROOF + RESULTS";
}
function buildHUD(){
  const hud=$("#hud");
  hud.innerHTML = `
    <div class="topbar">
      <div class="brand">
        <span class="badge" id="modeBadge">${state.mode.toUpperCase()}</span>
        <div style="min-width:0">
          <div class="title" id="showTitle">${escapeHtml(state.leagueName)}</div>
          <div class="sub">${modeSub()}</div>
        </div>
      </div>
      <div class="right">
        <span class="badge">Commit: <span id="commitShort">${state.proof?.commit?.slice(0,10) ?? "—"}…</span></span>
        <button class="btn good" id="btnNext" ${nextDisabled() ? "disabled":""}>NEXT <span class="kbd">SPACE</span></button>
        <button class="btn" id="btnAudio">Audio: ${state.sfxOn?"ON":"OFF"}</button>
        <button class="btn" id="btnFull">Fullscreen <span class="kbd">F</span></button>
        <button class="btn primary" id="btnSetup">${state.uiOpen?"Hide":"Setup"}</button>
      </div>
    </div>

    <div class="panel" id="panel" style="display:${state.uiOpen?"block":"none"}">
      <div class="head">
        <div class="h">Setup</div>
        <div class="mini">Everything is editable. Use this panel during the show (it scrolls).</div>
      </div>
      <div class="body">
        <div class="field">
          <label>League name</label>
          <input id="leagueName" type="text" value="${escapeHtml(state.leagueName)}" />
        </div>

        <div class="row">
          <div class="field" style="flex:1; min-width:220px">
            <label>Last place (last season)</label>
            <input id="lastPlaceName" type="text" value="${escapeHtml(state.lastPlaceName)}"/>
          </div>
          <div class="field" style="flex:1; min-width:220px">
            <label>Champion (last season)</label>
            <input id="champName" type="text" value="${escapeHtml(state.champName)}"/>
          </div>
        </div>

        <div class="row">
          <div class="field" style="flex:1; min-width:180px">
            <label>Buy-in ($)</label>
            <input id="buyIn" type="number" min="0" step="1" value="${state.buyIn}"/>
          </div>
          <div class="field" style="flex:1; min-width:240px">
            <label>Briefcase number means…</label>
            <select id="penaltyMode">
              <option value="dollars" ${state.penaltyMode==="dollars"?"selected":""}>Dollars ($1–$50)</option>
              <option value="percent_of_buyin" ${state.penaltyMode==="percent_of_buyin"?"selected":""}>Percent of buy-in (1–50%)</option>
            </select>
            <div class="mini">Default: last place pays champion based on the revealed number.</div>
          </div>
        </div>

        <div class="row">
          <button class="btn smallbtn" id="btnAddTeam">Add team</button>
          <button class="btn smallbtn" id="btnSave">Save</button>
          <button class="btn smallbtn" id="btnLoad">Load</button>
          <button class="btn smallbtn" id="btnClear">Reset</button>
        </div>

        <div class="field" style="margin-top:12px">
          <label>Teams</label>
          <div class="teamList" id="teamList"></div>
        </div>

        <div class="row" style="margin-top:12px">
          <button class="btn gold" id="btnStart">Start Draft Night</button>
          <button class="btn danger" id="btnHardReset">Restart Run</button>
        </div>

        <div class="mini" style="margin-top:10px">
          Hotkeys: <span class="kbd">F</span> fullscreen • <span class="kbd">SPACE</span> next • <span class="kbd">N</span> next walk • Click = next / select
        </div>
      </div>
    </div>
  `;
  $("#btnFull").onclick = ()=> toggleFullscreen();
  $("#btnSetup").onclick = ()=>{ state.uiOpen = !state.uiOpen; buildHUD(); };
  $("#btnAudio").onclick = ()=>{
    state.sfxOn = !state.sfxOn;
    if(state.sfxOn){ ensureAudio(); stinger(); }
    if(state.musicOn){ ensureAudio(); startMusic(); }
    else { stopMusic(); }
    saveCfg(); buildHUD();
  };
  $("#btnNext").onclick = ()=> onNext();

  $("#leagueName").oninput=(e)=>{ state.leagueName = (e.target.value||"").trim()||"Draft Night Show"; saveCfg(); buildHUD(); };
  $("#lastPlaceName").oninput=(e)=>{ state.lastPlaceName=(e.target.value||"").trim()||"Last Place"; saveCfg(); };
  $("#champName").oninput=(e)=>{ state.champName=(e.target.value||"").trim()||"Last Year Champ"; saveCfg(); };
  $("#buyIn").oninput=(e)=>{ state.buyIn=Math.max(0, +e.target.value||0); saveCfg(); };
  $("#penaltyMode").onchange=(e)=>{ state.penaltyMode=e.target.value; saveCfg(); };

  $("#btnAddTeam").onclick=()=>{
    const n = state.teams.length;
    const name = `Team ${String.fromCharCode(65+(n%26))}${n>=26?Math.floor(n/26):""}`;
    state.teams.push({name, color:"#3aa7ff"});
    saveCfg(); refreshSetupAppearances().then(()=>renderTeamList());
  };
  $("#btnSave").onclick=()=>{ saveCfg(); toast("SAVE","Saved","Setup saved to this browser"); };
  $("#btnLoad").onclick=()=>{ loadCfg(); buildHUD(); toast("LOAD","Loaded","Setup loaded from this browser"); };
  $("#btnClear").onclick=()=>{ clearCfg(); buildHUD(); toast("RESET","Defaults","Teams reset to defaults"); };
  $("#btnHardReset").onclick=()=>{ hardRestart(); };
  $("#btnStart").onclick=()=> startDraftNight();

  renderTeamList();
}
function renderTeamList(){
  const list=$("#teamList"); if(!list) return;
  list.innerHTML="";
  state.teams.forEach((t,i)=>{
    const el=document.createElement("div");
    el.className="teamItem";
    el.innerHTML=`
      <div class="swatch" style="background:${t.color}"></div>
      <input type="text" value="${escapeHtml(t.name)}" data-name="${i}">
      <input type="color" value="${t.color}" data-color="${i}">
      <button class="btn smallbtn" data-del="${i}">Del</button>
    `;
    list.appendChild(el);
  });
  list.querySelectorAll("input[data-name]").forEach(inp=>{
    inp.oninput=(e)=>{ const i=+e.target.dataset.name; state.teams[i].name=(e.target.value||"").trim()||state.teams[i].name; saveCfg(); };
  });
  list.querySelectorAll("input[data-color]").forEach(inp=>{
    inp.oninput=(e)=>{ const i=+e.target.dataset.color; state.teams[i].color=e.target.value; saveCfg(); refreshSetupAppearances().then(()=>renderTeamList()); };
  });
  list.querySelectorAll("button[data-del]").forEach(btn=>{
    btn.onclick=()=>{ const i=+btn.dataset.del; state.teams.splice(i,1); saveCfg(); refreshSetupAppearances().then(()=>renderTeamList()); };
  });
  // refresh lineup sprites (async)
  refreshSetupAppearances();

}


/* ---------- Canvas + sizing ---------- */
const canvas = $("#c");
const ctx = canvas.getContext("2d", { alpha:true });
let W=0,H=0,DPR=1;
function resize(){
  DPR = Math.max(1, Math.min(2, window.devicePixelRatio||1));
  W = Math.floor(window.innerWidth);
  H = Math.floor(window.innerHeight);
  canvas.width = Math.floor(W*DPR);
  canvas.height = Math.floor(H*DPR);
  canvas.style.width = W+"px";
  canvas.style.height = H+"px";
  ctx.setTransform(DPR,0,0,DPR,0,0);
}
window.addEventListener("resize", resize);

/* ---------- Confetti particles ---------- */
const confetti=[];
function spawnConfetti(n, palette){
  for(let i=0;i<n;i++){
    const col = palette ? palette[Math.floor(Math.random()*palette.length)] : (Math.random()<.5?"#ffbf2a":"#3aa7ff");
    confetti.push({
      x: lerp(W*0.12, W*0.88, Math.random()),
      y: -20,
      vx: lerp(-140,140, Math.random()),
      vy: lerp(220,520, Math.random()),
      r: lerp(0,Math.PI*2, Math.random()),
      vr: lerp(-10,10, Math.random()),
      s: lerp(6,12, Math.random()),
      life: lerp(1.1,2.0, Math.random()),
      c: col
    });
  }
}
function updateConfetti(dt){
  for(let i=confetti.length-1;i>=0;i--){
    const p=confetti[i];
    p.life -= dt;
    p.x += p.vx*dt;
    p.y += p.vy*dt;
    p.vy += 300*dt;
    p.r += p.vr*dt;
    if(p.life<=0 || p.y>H+60) confetti.splice(i,1);
  }
}
function drawConfetti(){
  for(const p of confetti){
    ctx.save();
    ctx.translate(p.x,p.y);
    ctx.rotate(p.r);
    ctx.fillStyle = p.c;
    ctx.globalAlpha = clamp(p.life,0,1);
    ctx.fillRect(-p.s/2, -p.s/2, p.s, p.s*1.6);
    ctx.restore();
  }
  ctx.globalAlpha=1;
}

/* ---------- Drawing helpers ---------- */
function drawText(x,y,text, size=16, color="rgba(244,247,255,.9)", weight="700", align="left"){
  ctx.save();
  ctx.fillStyle=color;
  ctx.font = `${weight} ${size}px ${getComputedStyle(document.documentElement).getPropertyValue('--sans')}`;
  ctx.textAlign=align;
  ctx.textBaseline="top";
  ctx.fillText(text,x,y);
  ctx.restore();
}
function drawMono(x,y,text, size=12, color="rgba(244,247,255,.82)", align="left"){
  ctx.save();
  ctx.fillStyle=color;
  ctx.font = `900 ${size}px ${getComputedStyle(document.documentElement).getPropertyValue('--mono')}`;
  ctx.textAlign=align;
  ctx.textBaseline="top";
  ctx.fillText(text,x,y);
  ctx.restore();
}
function roundRect(x,y,w,h,r){
  const rr=Math.min(r, w/2, h/2);
  ctx.beginPath();
  ctx.moveTo(x+rr,y);
  ctx.arcTo(x+w,y,x+w,y+h,rr);
  ctx.arcTo(x+w,y+h,x,y+h,rr);
  ctx.arcTo(x,y+h,x,y,rr);
  ctx.arcTo(x,y,x+w,y,rr);
  ctx.closePath();
}

/* ---------- Flow controller ---------- */
function nextDisabled(){
  // disable NEXT while punishment reveals are running (so pacing stays dramatic)
  if(state.mode==="punishment"){
    return state.punishment.phase==="choose" || state.punishment.phase==="revealOthers" || state.punishment.phase==="revealChosenOpen" || state.punishment.phase==="revealChosenToast";
  }
  return false;
}
function onNext(){
  if(state.mode==="setup") return startDraftNight();
  if(state.mode==="punishment"){
    if(state.punishment.phase==="intro"){
      state.punishment.phase="choose";
      toast("PUNISHMENT","CHOOSE A BRIEFCASE", state.lastPlaceName.toUpperCase(), "Click a case");
      buildHUD();
    }else if(state.punishment.phase==="done"){
      startCombine();
      buildHUD();
    }
    return;
  }
  if(state.mode==="combine") return combineNext();
  if(state.mode==="stage") return stageNext();
  if(state.mode==="results") return hardRestart();
}
function startDraftNight(){
  if(state.teams.length<2){
    toast("ERROR","Add at least 2 teams","Setup panel → Add team");
    state.uiOpen=true; buildHUD(); return;
  }
  state.uiOpen=false;
  newProof().then(async (p)=>{
    state.proof=p;
    toast("LIVE","DRAFT NIGHT","Briefcases first","Press NEXT");
    
  if(state.musicOn){ startMusic(); }
    startPunishment();
    buildHUD();
  });
}
function toggleFullscreen(){
  if(!document.fullscreenElement) document.documentElement.requestFullscreen?.();
  else document.exitFullscreen?.();
}

/* =======================
   BRIEFCASE PUNISHMENT
======================= */
const punishScene = {
  spotT:0,
  flash:0,
  shake:0
};
function computePenaltyPayment(number){
  if(state.penaltyMode==="dollars") return number;
  const pct = number/100;
  return Math.round(state.buyIn * pct * 100)/100;
}
async function startPunishment(){
  state.mode="punishment";
  const p = state.punishment;
  p.phase="intro";
  p.finalNumber=null;
  p.chosenSlot=null;
  p.showFinal=false;
  p.revealQueue=[];
  p.revealTimer=0;

  // determine 5 unique numbers 1..50 from seed (provable)
  const seed = state.proof.seed;
  const nums=new Set();
  let i=0;
  while(nums.size<5){
    nums.add(await detInt(seed,"briefcase_value",i++,1,50));
  }
  const values=[...nums]; // 5 unique
  // shuffle case positions deterministically
  const idx=[0,1,2,3,4];
  for(let j=idx.length-1;j>0;j--){
    const k=await detInt(seed,"briefcase_shuffle",j,0,j);
    [idx[j],idx[k]]=[idx[k],idx[j]];
  }
  p.cases = idx.map((vIdx,slot)=>({
    slot,
    value: values[vIdx],
    opened:false,
    isChosen:false,
    openT:0
  }));

  toast("PUNISHMENT","LAST PLACE ON STAGE", `${state.lastPlaceName} chooses 1 of 5`, "NEXT");
}
function openCase(slot, chosen=false){
  const p=state.punishment;
  const c=p.cases[slot];
  if(!c || c.opened) return;
  c.opened=true;
  c.isChosen=chosen;
  c.openT=0.001;
  punishScene.flash = chosen ? 0.32 : 0.16;
  punishScene.shake = chosen ? 0.28 : 0.12;
  spawnConfetti(chosen?80:35, chosen?["#ffbf2a","#3aa7ff","#36e57a"]:["#ffbf2a","#3aa7ff"]);
  if(state.sfxOn){
    // metallic click
    tone(520,0.05,"square",0.02);
    setTimeout(()=>tone(780,0.05,"square",0.018),40);
    chosen ? stinger() : blip();
  }
}


function punishmentSelect(slot){
  const p=state.punishment;
  if(state.mode!=="punishment") return;
  if(p.phase!=="choose") return;

  // Lock selection but DO NOT open chosen yet.
  p.chosenSlot=slot;
  p.finalNumber = p.cases[slot].value;
  p.showFinal = false;

  // Queue the OTHER 4 cases to open first, then chosen opens last.
  p.phase="revealOthers";
  p.cases.forEach(c=>{ c.isChosen=false; });

  // Build a shuffled reveal queue for the non-chosen cases (seed-based)
  p.revealQueue = [0,1,2,3,4].filter(s=>s!==slot);
  const seed = state.proof.seed;
  Promise.all(p.revealQueue.map(async (s, idx)=>{
    const k = await detInt(seed, "briefcase_reveal_order", idx, 0, 999999);
    return {s,k};
  })).then(arr=>{
    arr.sort((a,b)=>a.k-b.k);
    p.revealQueue = arr.map(o=>o.s);
  });

  p.revealTimer = 1.0; // pause before first reveal
  p.chosenToastPending = true;
  p.chosenToastTimer = 0;

  toast("PUNISHMENT", "SELECTION LOCKED", `Case #${slot+1} chosen…`, "Opening the others first…");
  if(state.sfxOn){ thump(); }
  buildHUD();
}




function updatePunishment(dt){
  const p=state.punishment;
  punishScene.spotT += dt*0.8;
  punishScene.flash = Math.max(0, punishScene.flash - dt*1.4);
  punishScene.shake = Math.max(0, punishScene.shake - dt*1.8);

  // animate lids open
  for(const c of p.cases){
    if(c.opened && c.openT<1){
      c.openT = Math.min(1, c.openT + dt*0.9); // slow opening
    }
  }

  // Reveal flow:
  // 1) open the 4 non-chosen cases one-by-one (showing "miss" values)
  // 2) open chosen case last (NO number popup yet)
  // 3) AFTER chosen is fully opened + a beat, show the chosen popup (so nothing is spoiled early)
  if(p.phase==="revealOthers"){
    if(p.revealQueue.length){
      p.revealTimer -= dt;
      if(p.revealTimer<=0){
        const next = p.revealQueue.shift();
        openCase(next,false);
        const v = p.cases[next].value;
        toast("MISS", `CASE #${next+1} WAS`, `${v}`, "");
        p.revealTimer = 1.25 + Math.random()*0.5;
      }
    }else{
      p.phase="revealChosenOpen";
      p.revealTimer = 1.6; // dramatic pause
      toast("…", "LAST CASE", "Open the chosen case…", "");
      if(state.sfxOn){ tone(220,.14,"triangle",.04); }
      buildHUD();
    }
  }else if(p.phase==="revealChosenOpen"){
    p.revealTimer -= dt;
    if(p.revealTimer<=0){
      const slot = p.chosenSlot;
      if(slot!=null){
        p.cases[slot].isChosen=true;
        openCase(slot,true);
      }
      // Wait until the chosen lid is fully open, then show popup
      p.phase="revealChosenToast";
      p.chosenToastTimer = 0.0;
      buildHUD();
    }
  }else if(p.phase==="revealChosenToast"){
    p.chosenToastTimer += dt;
    const slot = p.chosenSlot;
    const openedEnough = (slot!=null && p.cases[slot].openT >= 1);
    if(openedEnough && p.chosenToastTimer >= 0.55){
      const num = p.finalNumber;
      const pay = computePenaltyPayment(num);
      p.showFinal = true;
      toast("LOCKED", `CHOSEN CASE #${slot+1}`, `Number: ${num} → $${pay.toFixed(2)}`, "");
      toast("LOCKED", "PUNISHMENT SET", `${state.lastPlaceName} pays ${state.champName}`, "NEXT to Combine");
      p.phase="done";
      buildHUD();
    }
  }
}


function renderPunishment(dt){
  // dark stage + sweeping spotlights
  ctx.fillStyle="#05070c"; ctx.fillRect(0,0,W,H);

  const shake = punishScene.shake>0 ? (Math.sin(perf*0.09)*punishScene.shake*16) : 0;
  ctx.save();
  ctx.translate(shake, 0);

  // spotlights
  const t=punishScene.spotT;
  for(let i=0;i<4;i++){
    const cx = W*(0.18+i*0.22) + Math.sin(t*0.9 + i)*150;
    const rot = (-0.22 + i*0.11) + Math.sin(t*0.7 + i)*0.06;
    ctx.save(); ctx.translate(cx, H*0.06); ctx.rotate(rot);
    ctx.fillStyle="rgba(255,191,42,.055)";
    ctx.fillRect(-170, 0, 340, H);
    ctx.restore();
  }

  // header
  drawText(W*0.06, H*0.07, "PUNISHMENT REVEAL", 64, "rgba(244,247,255,.95)", "950");
  drawText(W*0.06, H*0.16, `${state.lastPlaceName.toUpperCase()} PICKS 1 CASE`, 16, "rgba(244,247,255,.74)", "900");
  drawText(W*0.06, H*0.19, "Then we open the rest… slowly… so everyone can laugh.", 14, "rgba(244,247,255,.62)", "800");

  // stage deck
  ctx.fillStyle="rgba(255,255,255,.03)";
  roundRect(W*0.04, H*0.30, W*0.92, H*0.60, 24); ctx.fill();
  ctx.strokeStyle="rgba(255,255,255,.10)"; ctx.lineWidth=2; ctx.stroke();

  // cases layout
  const p=state.punishment;
  const gap = W*0.145;
  const startX = W*0.20;
  const y = H*0.60;
  for(let i=0;i<5;i++){
    const x = startX + i*gap;
    drawBriefcase2D(i, x, y, p.cases[i]);
  }

  // payment card (only AFTER full reveal)
  if(p.showFinal){
    const pay = computePenaltyPayment(p.finalNumber);
    ctx.fillStyle="rgba(0,0,0,.55)";
    roundRect(W*0.06, H*0.23, W*0.62, 92, 18); ctx.fill();
    ctx.strokeStyle="rgba(255,255,255,.12)"; ctx.lineWidth=2; ctx.stroke();
    drawText(W*0.08, H*0.245, "PUNISHMENT LOCK-IN", 12, "rgba(244,247,255,.72)", "950");
    drawText(W*0.08, H*0.265, `NUMBER: ${p.finalNumber}   →   $${pay.toFixed(2)}`, 28, "#ffbf2a", "1000");
    drawText(W*0.08, H*0.305, `${state.lastPlaceName} pays ${state.champName}`, 12, "rgba(244,247,255,.70)", "900");
  }

  ctx.restore();

  if(punishScene.flash>0){
    ctx.fillStyle=`rgba(255,191,42,${punishScene.flash})`;
    ctx.fillRect(0,0,W,H);
  }

  drawConfetti();
}

function drawBriefcase2D(slot, x, y, c){
  // c.openT in [0,1] controls lid angle
  const w=110, h=78;
  const opened=c.opened;
  const chosen=c.isChosen;
  const hover = (state.punishment.hover===slot) && (state.punishment.phase==="choose");
  const glow = (chosen?0.85:(hover?0.55:0.22));

  // base case body
  ctx.save();
  ctx.translate(x,y);

  // shadow
  ctx.fillStyle="rgba(0,0,0,.30)";
  ctx.beginPath(); ctx.ellipse(0, h*0.70, 54, 10, 0, 0, Math.PI*2); ctx.fill();

  // body
  ctx.fillStyle= opened ? "rgba(255,255,255,.08)" : "rgba(0,0,0,.40)";
  roundRect(-w/2, -h/2, w, h, 16); ctx.fill();
  ctx.strokeStyle = chosen ? `rgba(255,191,42,${glow})` : `rgba(255,255,255,${glow})`;
  ctx.lineWidth=3; ctx.stroke();

  // handle
  ctx.strokeStyle="rgba(244,247,255,.75)";
  ctx.lineWidth=4;
  ctx.beginPath();
  ctx.arc(0, -h/2+14, 18, Math.PI, 0);
  ctx.stroke();

  // number badge (slot number)
  ctx.fillStyle="rgba(255,191,42,.18)";
  roundRect(-22, -h/2+22, 44, 26, 12); ctx.fill();
  ctx.strokeStyle="rgba(255,191,42,.35)"; ctx.lineWidth=1; ctx.stroke();
  ctx.fillStyle="rgba(244,247,255,.92)";
  ctx.font=`950 14px ${getComputedStyle(document.documentElement).getPropertyValue('--sans')}`;
  ctx.textAlign="center"; ctx.textBaseline="middle";
  ctx.fillText(String(slot+1), 0, -h/2+35);

  // lid animation
  if(opened){
    const t = c.openT; // 0..1
    const ang = (-1.1)*t; // rotate up
    ctx.save();
    ctx.translate(0, -h/2+14);
    ctx.rotate(ang);
    ctx.translate(0, -(h*0.30));
    ctx.fillStyle="rgba(255,255,255,.06)";
    roundRect(-w/2, -h/2, w, h*0.40, 16); ctx.fill();
    ctx.strokeStyle=chosen ? "rgba(255,191,42,.40)" : "rgba(255,255,255,.18)";
    ctx.lineWidth=2; ctx.stroke();
    ctx.restore();

    // reveal panel
    const revealAlpha = clamp((t-0.25)/0.75, 0, 1);
    ctx.globalAlpha = revealAlpha;
    ctx.fillStyle="rgba(0,0,0,.35)";
    roundRect(-w*0.30, -h*0.05, w*0.60, h*0.42, 12); ctx.fill();
    ctx.strokeStyle= chosen ? "rgba(255,191,42,.55)" : "rgba(255,255,255,.22)";
    ctx.lineWidth=2; ctx.stroke();
    ctx.fillStyle= chosen ? "#ffbf2a" : "rgba(244,247,255,.85)";
    ctx.font=`1000 30px ${getComputedStyle(document.documentElement).getPropertyValue('--sans')}`;
    ctx.fillText(String(c.value), 0, 8);
    ctx.globalAlpha=1;
  }else{
    ctx.fillStyle="rgba(244,247,255,.72)";
    ctx.font=`900 12px ${getComputedStyle(document.documentElement).getPropertyValue('--mono')}`;
    ctx.fillText("CLOSED", 0, 10);
  }

  // hover hint
  if(hover){
    ctx.fillStyle="rgba(255,191,42,.12)";
    roundRect(-w/2-6, -h/2-6, w+12, h+12, 18); ctx.fill();
  }

  ctx.restore();
}
function punishmentHandleMove(mx,my){
  if(state.mode!=="punishment") return;
  const p=state.punishment;
  p.hover=-1;
  if(p.phase!=="choose") return;
  const gap = W*0.145;
  const startX = W*0.20;
  const y = H*0.60;
  for(let i=0;i<5;i++){
    const x = startX + i*gap;
    const w=110, h=78;
    const left=x-w/2, top=y-h/2;
    if(mx>=left && mx<=left+w && my>=top && my<=top+h){
      p.hover=i; break;
    }
  }
}
function punishmentHandleClick(mx,my){
  if(state.mode!=="punishment") return false;
  const p=state.punishment;
  if(p.phase!=="choose") return false;
  const gap = W*0.145;
  const startX = W*0.20;
  const y = H*0.60;
  for(let i=0;i<5;i++){
    const x = startX + i*gap;
    const w=110, h=78;
    const left=x-w/2, top=y-h/2;
    if(mx>=left && mx<=left+w && my>=top && my<=top+h){
      punishmentSelect(i);
      return true;
    }
  }
  return false;
}

/* =======================
   COMBINE (manual, round-based)
======================= */
const combineScene = {
  eventIndex:0, teamIndex:0,
  phase:"intro",
  t:0, flash:0,
  player:{x:0,y:0,bob:0},
  reps:0, repTimer:0,
};

async function buildAppearance(seed, i, fallbackColor){
  // Deterministic, seed-based "paper-doll" style look for each team.
  const skinPalette = ["#f6d4c1","#f2c7a1","#e7b48d","#d89a74","#c4825f","#a96543","#8a4f33","#6b3d28","#4d2b1f"];
  const hairPalette = ["#1c1b1b","#3a2a1a","#5a3a22","#7a4a2a","#caa064","#e0c58c","#b03030","#2b4a7a","#2a7a4a"];
  const hatTypes = ["none","cap","beanie","helmet","bandana"];
  const visorTypes = ["none","clear","dark"];
  const jerseyTypes = ["solid","stripes","diagonal","panel","twoTone"];
  const sockTypes = ["low","mid","high"];
  const num = await detInt(seed,"sprite_num",i,0,99);

  const skin = skinPalette[await detInt(seed,"sprite_skin",i,0,skinPalette.length-1)];
  const hair = hairPalette[await detInt(seed,"sprite_hair",i,0,hairPalette.length-1)];
  const hat = hatTypes[await detInt(seed,"sprite_hat",i,0,hatTypes.length-1)];
  const visor = visorTypes[await detInt(seed,"sprite_visor",i,0,visorTypes.length-1)];
  const jersey = jerseyTypes[await detInt(seed,"sprite_jersey",i,0,jerseyTypes.length-1)];
  const socks = sockTypes[await detInt(seed,"sprite_socks",i,0,sockTypes.length-1)];
  const accent = ["#ffbf2a","#3aa7ff","#36e57a","#ff3b4d","#b070ff","#ff7a3a"][await detInt(seed,"sprite_accent",i,0,5)];
  const trim = ["#ffffff","#0b0b10","#d7dbe6"][await detInt(seed,"sprite_trim",i,0,2)];
  const jerseyColor = fallbackColor || accent;

  return {skin,hair,hat,visor,jersey,socks,accent,trim,jerseyColor,num};
}


async function refreshSetupAppearances(){
  // Generate / refresh deterministic looks for the current team list (for the setup previews).
  if(!state.proof?.seed) return;
  const seed = state.proof.seed;
  state.appearance = state.appearance || {};
  for(let i=0;i<state.teams.length;i++){
    const team = state.teams[i];
    state.appearance[team.name] = await buildAppearance(seed, i, team.color);
  }
}

async function computeCombineMetrics(){
  const seed = state.proof.seed;
  const out=[];
  for(let i=0;i<state.teams.length;i++){
    const team=state.teams[i];
    // sprite appearance (deterministic)
    state.appearance[team.name] = await buildAppearance(seed, i, team.color);
    const forty = await detFloat(seed,"forty",i, 4.20, 5.85, 2);
    const bench = Math.round(await detFloat(seed,"bench",i, 6, 36, 0));
    const shuttle = await detFloat(seed,"shuttle",i, 3.80, 5.10, 2);
    out.push({team:team.name, color:team.color, forty, bench, shuttle});
  }
  state.combine.metrics = out;
  state.combine.revealed = {forty:{}, bench:{}, shuttle:{}};
  const totals=[];
  for(const m of out){
    const n40 = 1 - ((m.forty-4.20)/(5.85-4.20));
    const nSh = 1 - ((m.shuttle-3.80)/(5.10-3.80));
    const nBn = (m.bench-6)/(36-6);
    const score = (n40*2.6 + nSh*1.8 + nBn*1.3) * 50;
    totals.push({team:m.team, color:m.color, score});
  }
  state.combine.totals = totals;
}
function startCombine(){
  state.mode="combine";
  combineScene.eventIndex=0;
  combineScene.teamIndex=0;
  combineScene.phase="intro";
  combineScene.t=0;
  computeCombineMetrics().then(()=>{
    toast("LIVE","COMBINE FIELD", "Round 1: 40-YD DASH", "NEXT to start");
    buildHUD();
  });
}
function combineNext(){
  if(state.mode!=="combine") return;
  const m=currentMetric();
  if(!m) return;
  if(combineScene.phase==="intro"){
    combineScene.phase="anim";
    combineScene.t=0; combineScene.reps=0; combineScene.repTimer=0;
    if(state.sfxOn){ whistle(); }
    spawnConfetti(18, ["#3aa7ff","#ffbf2a"]);
    
  if(state.musicOn){ startMusic(); }
    return;
  }
  if(combineScene.phase==="anim"){
    combineScene.t = 999;
    return;
  }
  if(combineScene.phase==="done"){
    const teamName=m.team;
    if(combineScene.eventIndex===0) state.combine.revealed.forty[teamName]=m.forty;
    if(combineScene.eventIndex===1) state.combine.revealed.bench[teamName]=m.bench;
    if(combineScene.eventIndex===2) state.combine.revealed.shuttle[teamName]=m.shuttle;

    combineScene.teamIndex++;
    if(combineScene.teamIndex >= state.combine.metrics.length){
      combineScene.teamIndex=0;
      combineScene.eventIndex++;
      if(combineScene.eventIndex>=3){
        endCombineToStage();
        return;
      }else{
        const evName=["40-YD DASH","BENCH PRESS","20-YD SHUTTLE"][combineScene.eventIndex];
        toast("ROUND", `NEXT EVENT`, evName, "NEXT to start");
      }
    }else{
      toast("NEXT UP", state.combine.metrics[combineScene.teamIndex].team.toUpperCase(), "Ready for the drill", "NEXT to start");
    }
    combineScene.phase="intro";
    combineScene.t=0;
  }
}
function endCombineToStage(){
  const sorted=[...state.combine.totals].sort((a,b)=>b.score-a.score);
  state.order=sorted.map(x=>x.team);
  state.orderStats = sorted.map(x=>{
    const m = state.combine.metrics.find(mm=>mm.team===x.team);
    return {team:x.team, color:x.color, score:x.score, forty:m.forty, bench:m.bench, shuttle:m.shuttle};
  });

  state.mode="stage";
  stageScene.index=0;
  stageScene.walking=false;
  stageScene.walkT=0;
  stageScene.flashT=0;
  stageScene.spotT=0;
  stageScene._lt="THE PICK IS IN…";
  toast("LIVE","DRAFT STAGE","Walk-ons by Combine Total", "NEXT to reveal");
  spawnConfetti(120, ["#ffbf2a","#3aa7ff","#36e57a","#ff3b4d"]);
  if(state.sfxOn){ crowd(); }
  buildHUD();
}
function currentMetric(){ return state.combine.metrics[combineScene.teamIndex]; }

/* ---------- Combine render (reused from v2) ---------- */
function drawCone(x,y,s){
  ctx.save(); ctx.translate(x,y);
  ctx.fillStyle="rgba(0,0,0,.18)";
  ctx.fillRect(-s*0.35, s*0.55, s*0.7, 4);
  ctx.fillStyle="#ffbf2a";
  ctx.beginPath();
  ctx.moveTo(-s*0.55, s*0.55);
  ctx.lineTo(0, -s*0.70);
  ctx.lineTo(s*0.55, s*0.55);
  ctx.closePath(); ctx.fill();
  ctx.restore();
}
function drawBarbell(x,y,scale){
  ctx.save(); ctx.translate(x,y); ctx.scale(scale,scale);
  ctx.fillStyle="rgba(244,247,255,.95)";
  ctx.fillRect(-32, -3, 64, 6);
  ctx.fillRect(-32, -11, 10, 22);
  ctx.fillRect(22, -11, 10, 22);
  ctx.restore();
}

function drawPlayer(x,y,teamColor,run=false,pose="run", appearance=null){
  const app = appearance || {skin:"#e7b48d", hair:"#1c1b1b", hat:"cap", visor:"none", jersey:"solid", socks:"mid", accent:"#ffbf2a", trim:"#ffffff", jerseyColor:teamColor||"#3aa7ff", num:12};
  const rgb=hexToRgb(app.jerseyColor||teamColor||"#3aa7ff");
  const aRgb=hexToRgb(app.accent||"#ffbf2a");
  const tRgb=hexToRgb(app.trim||"#ffffff");
  ctx.save(); ctx.translate(x,y);

  const legSwing = run ? Math.sin(combineScene.t*9)*10 : 0;
  const bounce = run ? Math.sin(combineScene.t*14)*2.5 : 0;
  ctx.translate(0, -bounce);

  // ---- Shadow
  ctx.fillStyle="rgba(0,0,0,.28)";
  ctx.beginPath(); ctx.ellipse(0, 60, 42, 9, 0, 0, Math.PI*2); ctx.fill();

  // ---- Legs + socks
  const sockH = app.socks==="low" ? 8 : app.socks==="mid" ? 14 : 20;
  const legH = 26;
  for(const side of [-1,1]){
    ctx.save();
    ctx.translate(side*10, 26);
    ctx.rotate((side*legSwing*Math.PI/180));
    ctx.fillStyle="rgba(244,247,255,.92)";
    roundRect(-4,0,8,legH,4); ctx.fill();
    ctx.fillStyle=`rgba(${tRgb.r},${tRgb.g},${tRgb.b},.92)`;
    roundRect(-4,legH-sockH,8,sockH,4); ctx.fill();
    ctx.restore();
  }

  // ---- Torso (jersey base)
  ctx.fillStyle=`rgb(${rgb.r},${rgb.g},${rgb.b})`;
  roundRect(-26, -6, 52, 34, 12); ctx.fill();

  // jersey pattern overlay
  if(app.jersey==="stripes"){
    ctx.fillStyle=`rgba(${aRgb.r},${aRgb.g},${aRgb.b},.85)`;
    ctx.fillRect(-26, 4, 52, 6);
    ctx.fillRect(-26, 16, 52, 6);
  }else if(app.jersey==="diagonal"){
    ctx.save();
    ctx.rotate(-0.35);
    ctx.fillStyle=`rgba(${aRgb.r},${aRgb.g},${aRgb.b},.85)`;
    ctx.fillRect(-40, 2, 90, 8);
    ctx.restore();
  }else if(app.jersey==="panel"){
    ctx.fillStyle=`rgba(${aRgb.r},${aRgb.g},${aRgb.b},.75)`;
    roundRect(-26, -6, 18, 34, 10); ctx.fill();
    roundRect(8, -6, 18, 34, 10); ctx.fill();
  }else if(app.jersey==="twoTone"){
    ctx.fillStyle=`rgba(${aRgb.r},${aRgb.g},${aRgb.b},.75)`;
    roundRect(-26, 10, 52, 18, 10); ctx.fill();
  }

  // trim neckline
  ctx.strokeStyle=`rgba(${tRgb.r},${tRgb.g},${tRgb.b},.9)`;
  ctx.lineWidth=2;
  ctx.beginPath(); ctx.arc(0,-6, 10, Math.PI*0.15, Math.PI*0.85); ctx.stroke();

  // ---- Arms
  const armY = (pose==="bench") ? 2 : -2;
  // sleeves
  ctx.fillStyle=`rgba(${aRgb.r},${aRgb.g},${aRgb.b},.9)`;
  roundRect(-32, armY, 10, 18, 5); ctx.fill();
  roundRect(22, armY, 10, 18, 5); ctx.fill();
  // forearms (skin)
  const sRgb=hexToRgb(app.skin);
  ctx.fillStyle=`rgba(${sRgb.r},${sRgb.g},${sRgb.b},.95)`;
  roundRect(-32, armY+10, 10, 12, 5); ctx.fill();
  roundRect(22, armY+10, 10, 12, 5); ctx.fill();

  // ---- Head (skin) + face
  ctx.fillStyle=`rgba(${sRgb.r},${sRgb.g},${sRgb.b},.98)`;
  roundRect(-18, -34, 36, 26, 12); ctx.fill();
  ctx.fillStyle="rgba(0,0,0,.22)";
  roundRect(-12, -28, 24, 14, 8); ctx.fill();

  // visor overlay
  if(app.visor==="clear"){
    ctx.fillStyle="rgba(180,220,255,.25)";
    roundRect(-12, -28, 24, 14, 8); ctx.fill();
  }else if(app.visor==="dark"){
    ctx.fillStyle="rgba(0,0,0,.45)";
    roundRect(-12, -28, 24, 14, 8); ctx.fill();
  }

  // hair / hat / helmet
  const hRgb=hexToRgb(app.hair);
  if(app.hat==="none"){
    ctx.fillStyle=`rgba(${hRgb.r},${hRgb.g},${hRgb.b},.92)`;
    roundRect(-16, -36, 32, 10, 10); ctx.fill();
  }else if(app.hat==="cap"){
    ctx.fillStyle=`rgba(${hRgb.r},${hRgb.g},${hRgb.b},.92)`;
    roundRect(-18, -40, 36, 12, 10); ctx.fill();
    ctx.fillStyle=`rgba(${tRgb.r},${tRgb.g},${tRgb.b},.88)`;
    roundRect(0, -36, 22, 6, 6); ctx.fill();
  }else if(app.hat==="beanie"){
    ctx.fillStyle=`rgba(${aRgb.r},${aRgb.g},${aRgb.b},.92)`;
    roundRect(-18, -40, 36, 14, 12); ctx.fill();
  }else if(app.hat==="bandana"){
    ctx.fillStyle=`rgba(${aRgb.r},${aRgb.g},${aRgb.b},.92)`;
    roundRect(-18, -38, 36, 10, 10); ctx.fill();
    ctx.beginPath(); ctx.moveTo(18,-34); ctx.lineTo(26,-30); ctx.lineTo(18,-28); ctx.closePath(); ctx.fill();
  }else if(app.hat==="helmet"){
    // helmet shell
    ctx.fillStyle=`rgba(${rgb.r},${rgb.g},${rgb.b},.95)`;
    roundRect(-20, -44, 40, 22, 14); ctx.fill();
    // stripe
    ctx.fillStyle=`rgba(${tRgb.r},${tRgb.g},${tRgb.b},.85)`;
    roundRect(-3, -44, 6, 22, 6); ctx.fill();
    // facemask
    ctx.strokeStyle="rgba(244,247,255,.85)";
    ctx.lineWidth=2;
    ctx.beginPath(); ctx.moveTo(10,-25); ctx.lineTo(20,-25); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(10,-22); ctx.lineTo(20,-22); ctx.stroke();
  }

  // ---- Jersey number
  ctx.fillStyle=`rgba(${tRgb.r},${tRgb.g},${tRgb.b},.92)`;
  ctx.font=`1000 14px ${getComputedStyle(document.documentElement).getPropertyValue('--mono')}`;
  ctx.textAlign="center"; ctx.textBaseline="middle";
  const numStr = String(app.num).padStart(2,"0");
  ctx.fillText(numStr, 0, 10);

  ctx.restore();
}

function combineBigText(m){
  if(!m) return {big:"—", small:"", color:"#ffbf2a"};
  if(combineScene.eventIndex===0){
    if(combineScene.phase==="done") return {big:`${m.forty.toFixed(2)}s`, small:"Official time posted • NEXT to continue", color:"#ffbf2a"};
    if(combineScene.phase==="anim") return {big:"RUNNING…", small:"Cameras tracking • Crowd loud", color:"#ffbf2a"};
    return {big:"READY", small:"Press NEXT to start the run", color:"rgba(244,247,255,.92)"};
  }
  if(combineScene.eventIndex===1){
    if(combineScene.phase==="done") return {big:`${m.bench} reps`, small:"Final reps posted • NEXT to continue", color:"#ffbf2a"};
    if(combineScene.phase==="anim") return {big:`${combineScene.reps} reps`, small:"Lift! Lift! Lift!", color:"#ffbf2a"};
    return {big:"READY", small:"Press NEXT to start the set", color:"rgba(244,247,255,.92)"};
  }
  if(combineScene.phase==="done") return {big:`${m.shuttle.toFixed(2)}s`, small:"Official time posted • NEXT to continue", color:"#ffbf2a"};
  if(combineScene.phase==="anim") return {big:"CUTTING…", small:"Feet moving • Clean turns", color:"#ffbf2a"};
  return {big:"READY", small:"Press NEXT to start the run", color:"rgba(244,247,255,.92)"};
}
function updateCombine(dt){
  if(state.mode!=="combine") return;
  const m=currentMetric(); if(!m) return;
  combineScene.t += dt;
  const trackY=H*0.60;
  const startX=W*0.20, finishX=W*0.72;
  const leftX=startX+120, rightX=finishX-120;

  if(combineScene.phase==="intro"){
    combineScene.player.x=startX; combineScene.player.y=trackY;
    combineScene.t=0; combineScene.reps=0; combineScene.repTimer=0;
    return;
  }
  if(combineScene.phase==="anim"){
    if(combineScene.eventIndex===0){
      const dur = clamp(m.forty*0.32, 1.4, 3.2);
      const t = clamp(combineScene.t/dur, 0, 1);
      combineScene.player.x = lerp(startX, finishX, easeInOut(t));
      if(t>=1 || combineScene.t>50){
        combineScene.phase="done";
        blip(); spawnConfetti(45, ["#ffbf2a","#3aa7ff"]);
        toast("RESULT", m.team.toUpperCase(), `${m.forty.toFixed(2)}s`, "NEXT");
      }
    } else if(combineScene.eventIndex===1){
      const target=m.bench;
      combineScene.repTimer += dt;
      const interval = 0.16;
      if(combineScene.reps<target && combineScene.repTimer>=interval){
        combineScene.repTimer=0;
        combineScene.reps++;
        if(combineScene.reps%3===0) thump();
      }
      if(combineScene.reps>=target || combineScene.t>50){
        combineScene.phase="done";
        blip(); spawnConfetti(45, ["#ffbf2a","#36e57a"]);
        toast("RESULT", m.team.toUpperCase(), `${m.bench} reps`, "NEXT");
      }
    } else {
      const total = clamp(m.shuttle*0.42, 1.6, 3.4);
      const seg = total/3;
      const t0 = clamp(combineScene.t/seg, 0, 3);
      let x=startX;
      if(t0<=1) x=lerp(startX, leftX, easeInOut(t0));
      else if(t0<=2) x=lerp(leftX, rightX, easeInOut(t0-1));
      else x=lerp(rightX, (leftX+rightX)/2, easeInOut(t0-2));
      combineScene.player.x=x;
      if(combineScene.t>=total || combineScene.t>50){
        combineScene.phase="done";
        blip(); spawnConfetti(45, ["#ffbf2a","#3aa7ff"]);
        toast("RESULT", m.team.toUpperCase(), `${m.shuttle.toFixed(2)}s`, "NEXT");
      }
    }
  }
}
function renderCombine(dt){
  const turfTop = H*0.28, turfH=H*0.56;
  ctx.fillStyle="#071118"; ctx.fillRect(0,0,W,H);
  for(let i=0;i<14;i++){
    const y = turfTop + i*(turfH/14);
    ctx.fillStyle = (i%2===0) ? "#0d3a24" : "#0b331f";
    ctx.fillRect(0, y, W, turfH/14 + 2);
  }
  ctx.fillStyle="rgba(255,255,255,.06)";
  for(let x=0; x<W; x+=80) ctx.fillRect(x, turfTop, 3, turfH);
  ctx.fillStyle="rgba(0,0,0,.20)";
  ctx.fillRect(0, turfTop, W*0.18, turfH);
  ctx.fillRect(W*0.82, turfTop, W*0.18, turfH);

  ctx.fillStyle="rgba(0,0,0,.42)";
  roundRect(W*0.04, H*0.04, W*0.92, 130, 18); ctx.fill();
  ctx.strokeStyle="rgba(255,255,255,.12)"; ctx.lineWidth=2; ctx.stroke();

  const evNames=["40-YD DASH","BENCH PRESS","20-YD SHUTTLE"];
  const evName=evNames[combineScene.eventIndex]||"—";
  const roundLabel=`ROUND ${combineScene.eventIndex+1}/3 • ${evName}`;
  drawText(W*0.06, H*0.055, "LEAGUE COMBINE", 50, "rgba(244,247,255,.95)", "950");
  drawText(W*0.06, H*0.125, roundLabel, 16, "rgba(244,247,255,.78)", "900");
  drawText(W*0.06, H*0.155, "Manual pacing — press NEXT to start each run", 13, "rgba(244,247,255,.62)", "800");

  ctx.fillStyle="rgba(0,0,0,.30)";
  roundRect(W*0.66, H*0.22, W*0.30, H*0.70, 18); ctx.fill();
  ctx.strokeStyle="rgba(255,255,255,.10)"; ctx.lineWidth=1; ctx.stroke();
  drawText(W*0.68, H*0.24, "EVENT RESULTS (SO FAR)", 14, "rgba(244,247,255,.92)", "950");
  let y=H*0.28;
  ctx.font=`900 13px ${getComputedStyle(document.documentElement).getPropertyValue('--mono')}`;
  ctx.fillStyle="rgba(244,247,255,.82)";
  ctx.textAlign="left"; ctx.textBaseline="top";
  const reveal = combineScene.eventIndex===0 ? state.combine.revealed.forty :
                 combineScene.eventIndex===1 ? state.combine.revealed.bench :
                 state.combine.revealed.shuttle;
  for(const tm of state.combine.metrics){
    const val = reveal[tm.team];
    let display="—";
    if(val!=null){
      display = (combineScene.eventIndex===1) ? `${val} reps` : `${(+val).toFixed(2)}s`;
    }
    ctx.fillText(`${tm.team.padEnd(16).slice(0,16)}  ${display}`, W*0.68, y);
    y+=18;
  }

  ctx.fillStyle="rgba(0,0,0,.35)";
  roundRect(W*0.04, H*0.20, W*0.58, 170, 18); ctx.fill();
  ctx.strokeStyle="rgba(255,255,255,.12)"; ctx.lineWidth=1; ctx.stroke();

  const m=currentMetric();
  const teamName=m?.team || "—";
  drawText(W*0.06, H*0.215, `NOW RUNNING: ${teamName.toUpperCase()}`, 22, "rgba(244,247,255,.92)", "950");
  drawText(W*0.06, H*0.248, `Event: ${evName}`, 14, "rgba(244,247,255,.70)", "900");

  const big = combineBigText(m);
  drawText(W*0.06, H*0.27, big.big, 58, big.color, "1000");
  drawText(W*0.06, H*0.345, big.small, 13, "rgba(244,247,255,.70)", "800");

  const trackY=H*0.60;
  const startX=W*0.20, finishX=W*0.72;
  ctx.fillStyle="rgba(255,255,255,.24)"; ctx.fillRect(startX-2, trackY-H*0.16, 4, H*0.32);
  ctx.fillStyle="rgba(255,191,42,.28)"; ctx.fillRect(finishX-2, trackY-H*0.16, 4, H*0.32);

  if(combineScene.eventIndex===2){
    drawCone(startX+120, trackY+90, 18);
    drawCone(finishX-120, trackY+90, 18);
  }
  if(combineScene.eventIndex===1){
    const by = trackY - 10 + (combineScene.phase==="anim" ? Math.sin(combineScene.t*20)*6 : 0);
    drawBarbell(W*0.46, by, 1.7);
  }

  const px=combineScene.player.x, py=combineScene.player.y;
  ctx.fillStyle="rgba(0,0,0,.32)";
  ctx.beginPath(); ctx.ellipse(px, py+56, 40, 9, 0, 0, Math.PI*2); ctx.fill();
  drawPlayer(px, py, m?.color||"#3aa7ff", combineScene.eventIndex!==1, combineScene.eventIndex===1?"bench":"run", state.appearance[m?.team] || null);

  updateCombine(dt);
  drawConfetti();
}

/* =======================
   DRAFT STAGE (manual)
======================= */
const stageScene = {
  index:0, walking:false, walkT:0, flashT:0, spotT:0,
  _walkerX:-80, _walkerY:0, _lt:"READY…"
};
function stageNext(){
  if(state.mode!=="stage") return;
  if(stageScene.walking) return;

  if(stageScene.index >= state.order.length){
    stageScene._lt="✅ ORDER LOCKED";
    spawnConfetti(140, ["#ffbf2a","#3aa7ff","#36e57a"]);
    if(state.sfxOn){ crowd(); }
    toast("DONE","ORDER LOCKED", "Proof screen next", "NEXT");
    state.mode="results";
    buildHUD();
    return;
  }

  const idx=stageScene.index;
  const stat=state.orderStats[idx];
  stageScene.index++;
  stageScene.walking=true;
  stageScene.walkT=0;
  stageScene.flashT=0.35;
  stageScene._lt = `#${idx+1}  ${stat.team.toUpperCase()}  •  TOTAL ${stat.score.toFixed(1)}`;
  toast("PICK IS IN", `#${idx+1} ${stat.team}`, `40=${stat.forty.toFixed(2)}s  Bench=${stat.bench}  Shuttle=${stat.shuttle.toFixed(2)}s`, "NEXT");
  if(state.sfxOn){ draftChime(); }
  spawnConfetti(70, ["#ffbf2a","#3aa7ff"]);
  
  if(state.musicOn){ startMusic(); }
}
function renderStage(dt){
  ctx.fillStyle="#05070c"; ctx.fillRect(0,0,W,H);
  stageScene.spotT += dt*0.7;
  for(let i=0;i<4;i++){
    const cx = W*(0.20+i*0.20) + Math.sin(stageScene.spotT*0.9 + i)*160;
    const rot = (-0.22 + i*0.11) + Math.sin(stageScene.spotT*0.7 + i)*0.06;
    ctx.save(); ctx.translate(cx, H*0.20); ctx.rotate(rot);
    ctx.fillStyle="rgba(58,167,255,.050)";
    ctx.fillRect(-150, 0, 300, H);
    ctx.restore();
  }
  ctx.fillStyle="#0b1022";
  roundRect(W*0.04, H*0.56, W*0.92, H*0.40, 20); ctx.fill();
  ctx.strokeStyle="rgba(255,255,255,.10)"; ctx.lineWidth=2; ctx.stroke();
  ctx.fillStyle="rgba(255,191,42,.22)"; ctx.fillRect(W*0.11, H*0.62, W*0.78, 12);
  ctx.fillStyle="rgba(58,167,255,.18)"; ctx.fillRect(W*0.13, H*0.66, W*0.74, 6);

  ctx.fillStyle="#0e1530";
  roundRect(W*0.60-110, H*0.56+60, 220, 150, 16); ctx.fill();
  ctx.strokeStyle="rgba(58,167,255,.22)"; ctx.lineWidth=2; ctx.stroke();
  drawText(W*0.60, H*0.56+85, "DRAFT PODIUM", 18, "rgba(244,247,255,.85)", "950", "center");

  drawText(W*0.06, H*0.07, "DRAFT STAGE", 56, "rgba(244,247,255,.95)", "950");
  drawText(W*0.06, H*0.15, "Manual reveal — press NEXT for each pick", 14, "rgba(244,247,255,.62)", "900");

  ctx.fillStyle="rgba(0,0,0,.28)";
  roundRect(W*0.04, H*0.40, W*0.34, H*0.52, 18); ctx.fill();
  ctx.strokeStyle="rgba(255,255,255,.12)"; ctx.lineWidth=1; ctx.stroke();
  drawText(W*0.06, H*0.42, "DRAFT BOARD", 16, "rgba(244,247,255,.92)", "950");
  ctx.fillStyle="rgba(244,247,255,.85)";
  ctx.font=`900 13px ${getComputedStyle(document.documentElement).getPropertyValue('--mono')}`;
  ctx.textAlign="left"; ctx.textBaseline="top";
  let y=H*0.46;
  for(let i=0;i<state.order.length;i++){
    const rank=String(i+1).padStart(2,"0");
    const shown = (i<stageScene.index) ? state.order[i] : "—";
    ctx.fillText(`${rank}. ${shown}`, W*0.06, y);
    y+=18;
  }

  ctx.fillStyle="rgba(0,0,0,.60)";
  roundRect(W*0.04, H*0.90, W*0.92, 92, 18); ctx.fill();
  ctx.strokeStyle="rgba(255,255,255,.12)"; ctx.lineWidth=1; ctx.stroke();
  drawText(W*0.06, H*0.912, stageScene._lt || "READY…", 32, "rgba(244,247,255,.95)", "1000");

  updateStage(dt);
  drawStageWalker();

  if(stageScene.flashT>0){
    ctx.fillStyle=`rgba(255,191,42,${stageScene.flashT})`;
    ctx.fillRect(0,0,W,H);
    stageScene.flashT = Math.max(0, stageScene.flashT - dt*1.8);
  }
  drawConfetti();
}
function updateStage(dt){
  if(stageScene.walking){
    stageScene.walkT += dt;
    const dur=2.0;
    const t=clamp(stageScene.walkT/dur,0,1);
    stageScene._walkerX = lerp(-120, W*0.56, easeInOut(t));
    stageScene._walkerY = H*0.75;
    if(t>=1){
      stageScene.walking=false;
      spawnConfetti(90, ["#ffbf2a","#3aa7ff","#36e57a"]);
      if(state.sfxOn){ crowd(); }
    }
  }
}

function drawStageWalker(){
  const idx = Math.max(0, stageScene.index-1);
  const teamName = state.order[idx];
  const team = state.teams.find(t=>t.name===teamName);
  const tint = team?.color || "#ffbf2a";
  const app = state.appearance[teamName] || null;

  // Shadow
  ctx.fillStyle="rgba(0,0,0,.35)";
  ctx.beginPath(); ctx.ellipse(stageScene._walkerX, stageScene._walkerY+84, 58, 12, 0, 0, Math.PI*2); ctx.fill();

  // Bigger character (reuse drawPlayer but scaled up)
  ctx.save();
  ctx.translate(stageScene._walkerX, stageScene._walkerY);
  ctx.scale(1.25,1.25);
  drawPlayer(0, 0, tint, true, "run", app);
  ctx.restore();

  // Draft card slide-in
  const show = !stageScene.walking && (teamName!=null);
  if(show){
    const cardW = Math.min(520, W*0.42);
    const cardH = 150;
    const cx = W*0.56 - cardW*0.10;
    const cy = H*0.56 + 42;
    ctx.fillStyle="rgba(0,0,0,.55)";
    roundRect(cx, cy, cardW, cardH, 18); ctx.fill();
    ctx.strokeStyle="rgba(255,255,255,.14)"; ctx.lineWidth=2; ctx.stroke();
    ctx.fillStyle="rgba(255,191,42,.16)";
    roundRect(cx+14, cy+14, 92, 32, 14); ctx.fill();
    ctx.strokeStyle="rgba(255,191,42,.26)"; ctx.lineWidth=1; ctx.stroke();
    ctx.fillStyle="rgba(244,247,255,.92)";
    ctx.font=`950 14px ${getComputedStyle(document.documentElement).getPropertyValue('--mono')}`;
    ctx.textAlign="center"; ctx.textBaseline="middle";
    ctx.fillText("PICK", cx+60, cy+30);

    const pickNum = String(idx+1).padStart(2,"0");
    ctx.font=`1000 42px ${getComputedStyle(document.documentElement).getPropertyValue('--mono')}`;
    ctx.fillStyle="#ffbf2a";
    ctx.fillText(pickNum, cx+60, cy+92);

    ctx.textAlign="left"; ctx.textBaseline="top";
    ctx.fillStyle="rgba(244,247,255,.95)";
    ctx.font=`1000 24px ${getComputedStyle(document.documentElement).getPropertyValue('--sans')}`;
    ctx.fillText(teamName.toUpperCase(), cx+120, cy+18);

    const stat = state.orderStats[idx];
    if(stat){
      ctx.fillStyle="rgba(244,247,255,.72)";
      ctx.font=`900 13px ${getComputedStyle(document.documentElement).getPropertyValue('--mono')}`;
      ctx.fillText(`TOTAL ${stat.score.toFixed(1)}`, cx+120, cy+54);
      ctx.fillText(`40: ${stat.forty.toFixed(2)}s    BENCH: ${stat.bench}    SHUTTLE: ${stat.shuttle.toFixed(2)}s`, cx+120, cy+76);
      if(app){
        ctx.fillText(`LOOK: ${app.hat.toUpperCase()} • ${app.jersey.toUpperCase()} • #${String(app.num).padStart(2,"0")}`, cx+120, cy+98);
      }
    }
  }
}


/* =======================
   RESULTS / PROOF
======================= */
function renderResults(dt){
  ctx.fillStyle="#05070c"; ctx.fillRect(0,0,W,H);

  drawText(W*0.06, H*0.07, "RESULTS + PROOF", 52, "rgba(244,247,255,.95)", "950");
  drawText(W*0.06, H*0.15, "Commit was shown all night. Seed is revealed now.", 14, "rgba(244,247,255,.74)", "900");

  ctx.fillStyle="rgba(0,0,0,.30)";
  roundRect(W*0.04, H*0.22, W*0.92, H*0.66, 18); ctx.fill();
  ctx.strokeStyle="rgba(255,255,255,.12)"; ctx.lineWidth=2; ctx.stroke();

  const x=W*0.07, y0=H*0.25;
  drawMono(x, y0, `commit: ${state.proof.commit}`, 13);
  drawMono(x, y0+20, `seed:   ${state.proof.seed}`, 13);

  drawMono(x, y0+52, "DRAFT ORDER:", 13);
  let y=y0+74;
  for(let i=0;i<state.orderStats.length;i++){
    const t=state.orderStats[i];
    drawMono(x, y, `${String(i+1).padStart(2,"0")}. ${t.team}  total=${t.score.toFixed(1)}  (40=${t.forty.toFixed(2)}  bench=${t.bench}  shuttle=${t.shuttle.toFixed(2)})`, 12, "rgba(244,247,255,.82)");
    y+=18;
    if(y>H*0.78) break;
  }

  const num = state.punishment.finalNumber;
  if(num!=null){
    const pay = computePenaltyPayment(num);
    drawMono(x, y+16, `PUNISHMENT: ${state.lastPlaceName} pays ${state.champName}  $${pay.toFixed(2)} (number=${num})`, 12, "rgba(255,191,42,.90)");
  }
  drawText(W*0.06, H*0.91, "Press NEXT / click to restart", 13, "rgba(244,247,255,.68)", "900");
  drawConfetti();
}

/* ---------- Setup screen render ---------- */

function renderSetup(dt){
  ctx.fillStyle="#05070c"; ctx.fillRect(0,0,W,H);

  // big background turf band
  const turfTop=H*0.34, turfH=H*0.52;
  ctx.fillStyle="rgba(13,58,36,.55)"; ctx.fillRect(0,turfTop,W,turfH);
  ctx.fillStyle="rgba(255,255,255,.06)";
  for(let x=0;x<W;x+=90) ctx.fillRect(x,turfTop,3,turfH);
  ctx.fillStyle="rgba(0,0,0,.26)";
  ctx.fillRect(0,turfTop,W*0.18,turfH); ctx.fillRect(W*0.82,turfTop,W*0.18,turfH);

  // yard lines (setup stage)
  ctx.fillStyle="rgba(255,255,255,.10)";
  for(let i=0;i<=10;i++){
    const x = lerp(W*0.08, W*0.92, i/10);
    ctx.fillRect(x, turfTop, 2, turfH);
  }
  ctx.fillStyle="rgba(255,255,255,.12)";
  ctx.fillRect(W*0.50, turfTop, 4, turfH);

  // titles
  drawText(W*0.06, H*0.16, "DRAFT NIGHT", 84, "rgba(244,247,255,.95)", "950");
  drawText(W*0.06, H*0.30, "SETUP YOUR LEAGUE • THEN HIT START", 18, "rgba(244,247,255,.74)", "900");
  drawText(W*0.06, H*0.35, "Punishment briefcase → combine rounds → draft stage walk-ons.", 14, "rgba(244,247,255,.62)", "800");

  // callout card
  ctx.fillStyle="rgba(0,0,0,.35)";
  roundRect(W*0.06, H*0.42, W*0.52, 88, 18); ctx.fill();
  ctx.strokeStyle="rgba(255,255,255,.14)"; ctx.lineWidth=2; ctx.stroke();
  drawText(W*0.08, H*0.445, "PRESS NEXT / SPACE TO START", 22, "#ffbf2a", "1000");
  drawText(W*0.08, H*0.475, "Edit teams on the right panel (it scrolls).", 12, "rgba(244,247,255,.70)", "900");

  // lineup stage: show every team's character on the field, dynamically.
  const boxX = W*0.06;
  const boxY = H*0.54;
  const boxW = W*0.74;
  const boxH = H*0.30;

  ctx.fillStyle="rgba(0,0,0,.28)";
  roundRect(boxX, boxY, boxW, boxH, 20); ctx.fill();
  ctx.strokeStyle="rgba(255,255,255,.12)"; ctx.lineWidth=2; ctx.stroke();
  drawText(boxX+18, boxY+12, "TEAM LINEUP (LIVE PREVIEW)", 14, "rgba(244,247,255,.92)", "950");

  const n = state.teams.length;
  if(n===0){
    drawText(boxX+18, boxY+40, "Add teams in the Setup panel.", 14, "rgba(244,247,255,.70)", "900");
    return;
  }

  // grid layout for sprites (auto wraps)
  const cols = Math.min(6, Math.max(2, Math.floor(boxW/160)));
  const rows = Math.ceil(n/cols);
  const cellW = boxW/cols;
  const cellH = Math.min(120, (boxH-52)/Math.max(1,rows));
  let idx=0;
  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      if(idx>=n) break;
      const team = state.teams[idx];
      const cx = boxX + c*cellW + cellW*0.50;
      const cy = boxY + 56 + r*cellH + cellH*0.55;

      // small podium shadow + sprite
      ctx.fillStyle="rgba(0,0,0,.25)";
      ctx.beginPath(); ctx.ellipse(cx, cy+62, 44, 9, 0, 0, Math.PI*2); ctx.fill();

      // scale down drawPlayer for lineup, no run bounce
      ctx.save();
      ctx.translate(cx, cy);
      ctx.scale(1.05,1.05);
      drawPlayer(0, 0, team.color, false, "run", state.appearance?.[team.name] || null);
      ctx.restore();

      // name tag
      ctx.fillStyle="rgba(0,0,0,.55)";
      roundRect(cx-70, cy+68, 140, 26, 12); ctx.fill();
      ctx.strokeStyle="rgba(255,255,255,.10)"; ctx.lineWidth=1; ctx.stroke();
      ctx.fillStyle="rgba(244,247,255,.92)";
      ctx.font=`900 12px ${getComputedStyle(document.documentElement).getPropertyValue('--mono')}`;
      ctx.textAlign="center"; ctx.textBaseline="middle";
      const label = (team.name||"TEAM").toUpperCase().slice(0,16);
      ctx.fillText(label, cx, cy+81);

      idx++;
    }
  }
}


/* ---------- Restart ---------- */
async function hardRestart(){
  state.mode="setup";
  stopMusic();
  state.proof = await newProof();
  await refreshSetupAppearances();
  state.combine.metrics=[];
  state.combine.totals=[];
  state.combine.revealed={forty:{},bench:{},shuttle:{}};
  state.order=[];
  state.orderStats=[];
  state.punishment.finalNumber=null;
  state.uiOpen=true;
  buildHUD();
  toast("READY","New run armed", "Commit updated", "NEXT");
}

/* ---------- Input ---------- */
window.addEventListener("keydown",(e)=>{
  const k=e.key.toLowerCase();
  if(k==="f") toggleFullscreen();
  if(k===" "){ onNext(); e.preventDefault(); }
  if(k==="n"){ if(state.mode==="stage") stageNext(); }
});
canvas.addEventListener("pointerdown",(ev)=>{
  const rect=canvas.getBoundingClientRect();
  const mx=(ev.clientX-rect.left);
  const my=(ev.clientY-rect.top);
  if(punishmentHandleClick(mx,my)) return;

  if(state.mode==="stage") stageNext();
  else if(state.mode==="results") hardRestart();
  else if(state.mode==="combine") onNext();
  else if(state.mode==="setup") onNext();
  else if(state.mode==="punishment"){
    // if intro or done, clicks act like NEXT
    if(state.punishment.phase==="intro" || state.punishment.phase==="done") onNext();
  }
});
canvas.addEventListener("pointermove",(ev)=>{
  const rect=canvas.getBoundingClientRect();
  const mx=(ev.clientX-rect.left);
  const my=(ev.clientY-rect.top);
  punishmentHandleMove(mx,my);
});

/* ---------- Main loop ---------- */
let last=performance.now();
let perf=0;
function tick(now){
  perf = now;
  const dt = clamp((now-last)/1000, 0, 0.033);
  last=now;

  if(state.mode==="setup") renderSetup(dt);
  else if(state.mode==="punishment"){ updatePunishment(dt); renderPunishment(dt); }
  else if(state.mode==="combine") renderCombine(dt);
  else if(state.mode==="stage") renderStage(dt);
  else if(state.mode==="results") renderResults(dt);

  updateConfetti(dt);
  requestAnimationFrame(tick);
}

/* ---------- Boot ---------- */
(async function boot(){
  loadCfg();
  resize();
  state.proof = await newProof();
  state.mode="setup";
  state.uiOpen=true;
  await refreshSetupAppearances();
  buildHUD();
  saveCfg();
  toast("READY","DRAFT NIGHT SHOW", "Setup → NEXT to start", "SPACE = NEXT");
  requestAnimationFrame(tick);
})();
</script>
</body>
</html>
